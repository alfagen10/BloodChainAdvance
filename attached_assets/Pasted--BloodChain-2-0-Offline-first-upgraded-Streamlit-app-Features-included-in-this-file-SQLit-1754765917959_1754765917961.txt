"""
BloodChain 2.0 — Offline-first upgraded Streamlit app
Features included in this file:
- SQLite backend (durable, concurrent-friendly)
- Persisted ML model (joblib) with RandomForest (optional if scikit-learn installed)
- Improved UI with your provided CSS (gradient overlay, card layout, nice inputs)
- Explicit blood type input on donation logging
- Cleaner errors and input validation
- Optional ONCHAIN support (disabled by default) — enable with env var ENABLE_ONCHAIN=true and required RPC env vars

Requirements (suggested):
streamlit, pandas, numpy, scikit-learn (optional), joblib (optional), web3 (optional), python-dotenv (optional)

Save as: bloodchain_full_upgrade_v2.py
"""

import streamlit as st
import sqlite3
import os
import time
import datetime
import uuid
from pathlib import Path
from typing import Dict, Any, List
import pandas as pd
import numpy as np

# Optional libs
try:
    from web3 import Web3
    from dotenv import load_dotenv
    load_dotenv()
    WEB3_AVAILABLE = True
except Exception:
    WEB3_AVAILABLE = False

try:
    from sklearn.ensemble import RandomForestClassifier
    SKLEARN_AVAILABLE = True
    import joblib
except Exception:
    SKLEARN_AVAILABLE = False

# ----------- CONFIG -----------
DB_PATH = Path("bloodchain.db")
MODEL_PATH = Path("model.joblib")

# ONCHAIN control: default False (offline-first). Set ENABLE_ONCHAIN=true to attempt on-chain setup.
ENABLE_ONCHAIN = os.getenv("ENABLE_ONCHAIN", "false").lower() in ("1", "true", "yes")
RPC_URL = os.getenv("RPC_URL", "")
PRIVATE_KEY = os.getenv("PRIVATE_KEY", "")
CONTRACT_ADDRESS = os.getenv("CONTRACT_ADDRESS", "")
CHAIN_ID = int(os.getenv("CHAIN_ID", "80002"))

BT_ORDER = ["A+","A-","B+","B-","AB+","AB-","O+","O-"]
BT_TO_CODE = {bt:i for i,bt in enumerate(BT_ORDER)}

# ----------- DB SETUP -----------
_conn: sqlite3.Connection = None

def get_conn() -> sqlite3.Connection:
    global _conn
    if _conn is None:
        _conn = sqlite3.connect(str(DB_PATH), check_same_thread=False)
        _conn.row_factory = sqlite3.Row
        init_db(_conn)
    return _conn


def init_db(conn: sqlite3.Connection):
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS donors (
        wallet TEXT PRIMARY KEY,
        name TEXT,
        blood_type TEXT,
        location TEXT,
        registered_at INTEGER,
        reward_points INTEGER DEFAULT 0
    )''')
    c.execute('''CREATE TABLE IF NOT EXISTS donations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        donor TEXT,
        blood_type TEXT,
        quantity INTEGER,
        timestamp INTEGER,
        hospital TEXT,
        location TEXT,
        tx_hash TEXT
    )''')
    conn.commit()

# ----------- UTILITIES -----------

def utc_ts() -> int:
    return int(time.time())


def ts_to_str(ts:int)->str:
    return datetime.datetime.utcfromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S UTC")


def mk_tx_hash() -> str:
    return "0x" + uuid.uuid4().hex[:16]

# ----------- ONCHAIN (optional) -----------
ONCHAIN = False
w3 = None
contract = None
acct = None

if ENABLE_ONCHAIN and WEB3_AVAILABLE and RPC_URL and PRIVATE_KEY and CONTRACT_ADDRESS:
    try:
        w3 = Web3(Web3.HTTPProvider(RPC_URL))
        # If ABI file provided in same folder, user can load it manually. Here we keep a minimal check.
        # ABI interaction omitted in offline-first default.
        acct = w3.eth.account.from_key(PRIVATE_KEY)
        ONCHAIN = True
    except Exception as e:
        ONCHAIN = False
        print("On-chain setup failed, fallback to offline mode. Error:", e)
else:
    ONCHAIN = False

# Placeholder on-chain functions (if user wants to wire contract ABI later)

def onchain_register_donor(wallet, name, blood_type, location):
    raise RuntimeError("On-chain register not implemented in this offline-first build.")


def onchain_log_donation(wallet, blood_type, qty, hospital):
    raise RuntimeError("On-chain log donation not implemented in this offline-first build.")

# ----------- STORAGE API -----------

def register_donor(wallet:str, name:str, blood_type:str, location:str):
    conn = get_conn()
    c = conn.cursor()
    wallet = wallet.strip()
    if not wallet:
        raise ValueError("Wallet/ID cannot be empty.")
    c.execute("SELECT 1 FROM donors WHERE wallet = ?", (wallet,))
    if c.fetchone():
        raise Exception("Donor already registered.")
    ts = utc_ts()
    c.execute("INSERT INTO donors (wallet,name,blood_type,location,registered_at,reward_points) VALUES (?, ?, ?, ?, ?, 0)",
              (wallet, name, blood_type, location, ts))
    conn.commit()
    return True


def log_donation(wallet:str, blood_type:str, qty:int, hospital:str):
    conn = get_conn()
    c = conn.cursor()
    wallet = wallet.strip()
    if qty <= 0:
        raise ValueError("Quantity must be >= 1")
    c.execute("SELECT location FROM donors WHERE wallet = ?", (wallet,))
    r = c.fetchone()
    if not r:
        raise Exception("Donor not registered.")
    location = r["location"]
    ts = utc_ts()
    tx = mk_tx_hash()
    c.execute("INSERT INTO donations (donor,blood_type,quantity,timestamp,hospital,location,tx_hash) VALUES (?, ?, ?, ?, ?, ?, ?)",
              (wallet, blood_type, int(qty), ts, hospital, location, tx))
    c.execute("UPDATE donors SET reward_points = reward_points + ? WHERE wallet = ?", (int(qty)*10, wallet))
    conn.commit()
    return tx


def get_history_for_wallet(wallet:str) -> List[Dict[str,Any]]:
    conn = get_conn()
    c = conn.cursor()
    c.execute("SELECT * FROM donations WHERE donor = ? ORDER BY timestamp DESC", (wallet,))
    rows = [dict(r) for r in c.fetchall()]
    return rows


def get_all_donations() -> List[Dict[str,Any]]:
    conn = get_conn()
    c = conn.cursor()
    c.execute("SELECT * FROM donations ORDER BY timestamp DESC")
    return [dict(r) for r in c.fetchall()]


def get_donor_count() -> int:
    conn = get_conn()
    c = conn.cursor()
    c.execute("SELECT COUNT(*) as c FROM donors")
    return c.fetchone()[0]


def get_total_units() -> int:
    conn = get_conn()
    c = conn.cursor()
    c.execute("SELECT SUM(quantity) as s FROM donations")
    s = c.fetchone()[0]
    return int(s or 0)

# ----------- AI SHORTAGE PREDICTOR -----------

MODEL = None
MODEL_MIN_SAMPLES = 30


def aggregate_weekly_counts(min_weeks=6) -> pd.DataFrame:
    rows = get_all_donations()
    if not rows:
        return pd.DataFrame(columns=["location","blood_type","week_start","total_units"])
    df = pd.DataFrame(rows)
    df["timestamp"] = pd.to_datetime(df["timestamp"], unit="s")
    df["week_start"] = df["timestamp"].dt.to_period('W').apply(lambda r: r.start_time)
    agg = df.groupby(["location","blood_type","week_start"])['quantity'].sum().reset_index()
    agg = agg.rename(columns={"quantity":"total_units"})
    return agg


def build_training_dataset(agg_df:pd.DataFrame, shortage_threshold=5) -> pd.DataFrame:
    if agg_df.empty:
        return pd.DataFrame()
    rows = []
    agg_df = agg_df.copy()
    agg_df['week_start'] = pd.to_datetime(agg_df['week_start'])
    grouped = agg_df.groupby(['location','blood_type'])
    for (loc, bt), group in grouped:
        group = group.sort_values('week_start').reset_index(drop=True)
        for i in range(len(group)-1):
            recent_units = group.loc[i, 'total_units']
            next_units = group.loc[i+1, 'total_units']
            label = 1 if next_units < shortage_threshold else 0
            rows.append({
                'location': loc,
                'blood_type': bt,
                'location_code': abs(hash(loc)) % 100,
                'blood_type_code': BT_TO_CODE.get(bt, 0),
                'recent_units': int(recent_units),
                'label': label
            })
    df = pd.DataFrame(rows)
    return df


def train_model_if_possible() -> bool:
    global MODEL
    agg = aggregate_weekly_counts()
    train_df = build_training_dataset(agg)
    if train_df.empty or len(train_df) < MODEL_MIN_SAMPLES or not SKLEARN_AVAILABLE:
        # try load persisted model if present
        if MODEL_PATH.exists() and SKLEARN_AVAILABLE:
            try:
                MODEL = joblib.load(str(MODEL_PATH))
                return True
            except Exception:
                MODEL = None
        return False
    X = train_df[["location_code","blood_type_code","recent_units"]].values
    y = train_df['label'].values
    clf = RandomForestClassifier(n_estimators=80, random_state=1)
    clf.fit(X,y)
    MODEL = clf
    try:
        joblib.dump(MODEL, str(MODEL_PATH))
    except Exception:
        pass
    return True


def predict_shortage(location:str) -> Dict[str, Any]:
    agg = aggregate_weekly_counts()
    subset = agg[agg['location']==location]
    results = {}
    if subset.empty:
        for bt in BT_ORDER:
            results[bt] = (0, 0.15)
        return results
    latest = subset.groupby('blood_type').apply(lambda g: g.sort_values('week_start').iloc[-1]).reset_index(drop=True)
    if MODEL is not None:
        for _, row in latest.iterrows():
            loc_code = abs(hash(location)) % 100
            bt_code = BT_TO_CODE.get(row['blood_type'], 0)
            recent = int(row['total_units'])
            prob = MODEL.predict_proba([[loc_code, bt_code, recent]])[0][1]
            pred = 1 if prob > 0.5 else 0
            results[row['blood_type']] = (int(pred), float(prob))
        for bt in BT_ORDER:
            if bt not in results:
                results[bt] = (0, 0.1)
        return results
    else:
        # heuristic fallback
        for bt in BT_ORDER:
            r = latest[latest['blood_type']==bt]
            recent = int(r.iloc[0]['total_units']) if not r.empty else 0
            if recent < 5:
                results[bt] = (1, 0.85)
            elif recent < 10:
                results[bt] = (0, 0.5)
            else:
                results[bt] = (0, 0.15)
        return results

# ----------- UI SETUP -----------

st.set_page_config(page_title="BloodChain 2.0 — Aidera (v2)", layout='wide', page_icon='🩸')

# Inject custom CSS (your provided style)
CUSTOM_CSS = r"""
<style>
    /* Background with gradient overlay */
    .stApp {
        background-image: linear-gradient(rgba(0,0,0,0.65), rgba(0,0,0,0.65)), 
                          url('https://images.unsplash.com/photo-1588776814546-9f9be06e3fa2?auto=format&fit=crop&w=1350&q=80');
        background-size: cover;
        background-position: center;
        color: #f0f0f0;
        font-family: 'Poppins', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* Container cards */
    .block-container {
        background-color: rgba(30, 30, 30, 0.85);
        border-radius: 15px;
        padding: 2rem;
        box-shadow: 0 8px 24px rgba(178, 34, 34, 0.3);
        margin-bottom: 2rem;
    }

    /* Headers */
    h1, h2, h3 {
        font-weight: 700;
        color: #b22222;
        letter-spacing: 0.05em;
        margin-bottom: 1rem;
    }

    /* Paragraphs and text */
    p, li {
        font-weight: 300;
        line-height: 1.6;
        color: #ddd;
    }

    /* Buttons */
    button {
        background-color: #b22222;
        color: white;
        border-radius: 30px;
        padding: 0.8rem 2rem;
        font-weight: 600;
        transition: background-color 0.3s ease;
        box-shadow: 0 4px 10px rgba(178, 34, 34, 0.5);
    }
    button:hover {
        background-color: #7a1212;
        box-shadow: 0 6px 15px rgba(178, 34, 34, 0.7);
        cursor: pointer;
    }

    /* Inputs */
    input, select {
        background-color: #2e2e2e;
        border-radius: 10px;
        padding: 0.6rem 1rem;
        color: #eee;
        border: 1px solid #555;
        transition: border-color 0.3s ease;
    }
    input:focus, select:focus {
        border-color: #b22222;
        outline: none;
        box-shadow: 0 0 8px #b22222;
    }

    /* Tables */
    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
        color: #f5f5f5;
    }
    th, td {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #444;
    }
    tr:hover {
        background-color: rgba(178, 34, 34, 0.2);
    }

    /* Sidebar */
    .css-1d391kg {
        background-color: #1f1f1f !important;
        color: #f0f0f0 !important;
        border-radius: 0 15px 15px 0;
    }

    /* subtle entrance */
    .fade-in { animation: fadeIn 0.6s ease both; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(6px);} to { opacity: 1; transform: none;} }

</style>
"""

st.markdown(CUSTOM_CSS, unsafe_allow_html=True)

# Sidebar and menu
st.sidebar.title("BloodChain — Controls")
menu = st.sidebar.radio("Menu", ["Dashboard","Register Donor","Log Donation","Track Donor","Hospital Dashboard","About"]) 

# Small badge for mode
if ONCHAIN:
    st.sidebar.success("🔗 ON-CHAIN mode")
else:
    st.sidebar.info("🧪 Offline / Mock mode")

# ----------- PAGES -----------

if menu == "Dashboard":
    st.markdown('<div class="block-container fade-in">', unsafe_allow_html=True)
    st.header("📊 Dashboard — Overview")
    donors_count = get_donor_count()
    total_donations = len(get_all_donations())
    total_units = get_total_units()
    col1, col2, col3 = st.columns(3)
    col1.metric("Registered donors", donors_count)
    col2.metric("Total donations logged", total_donations)
    col3.metric("Total blood units donated", total_units)

    st.subheader("Recent Donations")
    donations = get_all_donations()
    if donations:
        df = pd.DataFrame(donations)
        df['time_str'] = pd.to_datetime(df['timestamp'], unit='s').dt.strftime("%Y-%m-%d %H:%M:%S UTC")
        st.dataframe(df[['time_str','donor','blood_type','quantity','hospital','location','tx_hash']].sort_values('time_str',ascending=False).head(30))
    else:
        st.info("No donations logged yet.")
    st.markdown('</div>', unsafe_allow_html=True)

elif menu == "Register Donor":
    st.markdown('<div class="block-container fade-in">', unsafe_allow_html=True)
    st.header("👤 Register Donor")
    with st.form("register_form", clear_on_submit=True):
        wallet = st.text_input("Wallet Address or ID")
        name = st.text_input("Full Name")
        blood_type = st.selectbox("Blood Type", BT_ORDER)
        location = st.text_input("Location (City)")
        submitted = st.form_submit_button("Register")
    if submitted:
        try:
            if not wallet or not name or not location:
                st.error("Please fill in all fields.")
            else:
                register_donor(wallet, name, blood_type, location)
                st.success("Donor registered (offline).")
        except Exception as e:
            st.error(f"Error registering donor: {e}")
    st.markdown('</div>', unsafe_allow_html=True)

elif menu == "Log Donation":
    st.markdown('<div class="block-container fade-in">', unsafe_allow_html=True)
    st.header("🩺 Log Donation")
    with st.form("donation_form", clear_on_submit=True):
        wallet = st.text_input("Donor Wallet or ID")
        blood_type = st.selectbox("Blood Type", BT_ORDER)
        qty = st.number_input("Quantity (units)", min_value=1, step=1, value=1)
        hospital = st.text_input("Hospital or Donation Center")
        submitted = st.form_submit_button("Log Donation")
    if submitted:
        try:
            if not wallet or not hospital:
                st.error("Please provide donor wallet and hospital name.")
            else:
                tx_hash = log_donation(wallet, blood_type, qty, hospital)
                st.success(f"Donation logged. Tx Hash (mock): {tx_hash}")
        except Exception as e:
            st.error(f"Error logging donation: {e}")
    st.markdown('</div>', unsafe_allow_html=True)

elif menu == "Track Donor":
    st.markdown('<div class="block-container fade-in">', unsafe_allow_html=True)
    st.header("🔍 Track Donor History")
    wallet = st.text_input("Enter Donor Wallet or ID")
    if st.button("Fetch History"):
        if not wallet:
            st.warning("Enter a wallet or ID to fetch history.")
        else:
            try:
                rows = get_history_for_wallet(wallet)
                conn = get_conn()
                c = conn.cursor()
                c.execute("SELECT reward_points FROM donors WHERE wallet = ?", (wallet,))
                pts = c.fetchone()[0] if c.fetchone() is not None else 0
                if not rows:
                    st.info("No donations found for this donor.")
                else:
                    df = pd.DataFrame(rows)
                    df['time'] = pd.to_datetime(df['timestamp'], unit='s').dt.strftime('%Y-%m-%d %H:%M:%S UTC')
                    st.table(df[['time','blood_type','quantity','hospital','location','tx_hash']])
                    st.info(f"Reward Points: {pts}")
            except Exception as e:
                st.error(f"Error fetching donor history: {e}")
    st.markdown('</div>', unsafe_allow_html=True)

elif menu == "Hospital Dashboard":
    st.markdown('<div class="block-container fade-in">', unsafe_allow_html=True)
    st.header("🏥 Hospital Dashboard — Blood Shortage Prediction")
    st.markdown("Select location to view predicted shortage risk per blood type for next week.")

    donations = get_all_donations()
    locations = sorted(list({x['location'] for x in donations})) if donations else []
    use_custom = st.checkbox("Use custom location input")
    if use_custom:
        location = st.text_input("Enter custom location").strip()
        location = location if location else None
    else:
        location = st.selectbox("Select Location", options=["-- choose --"] + locations)
        location = location if location != "-- choose --" else None

    if location is None:
        st.info("Please select or enter a location with donation data to get predictions.")
    else:
        trained = train_model_if_possible()
        if trained:
            st.success("AI model loaded/trained successfully on historical data.")
        else:
            if SKLEARN_AVAILABLE:
                st.warning("Not enough training examples; using heuristic fallback.")
            else:
                st.warning("scikit-learn not installed; using heuristic fallback.")

        st.subheader(f"Predicted shortage risk for location: {location}")
        preds = predict_shortage(location)

        rows = []
        for bt, (label, prob) in preds.items():
            risk_level = "HIGH" if label == 1 else "LOW/MODERATE"
            rows.append({
                'Blood Type': bt,
                'Shortage Risk Probability': f"{prob:.0%}",
                'Risk Level': risk_level
            })
        dfp = pd.DataFrame(rows).sort_values('Shortage Risk Probability', ascending=False).reset_index(drop=True)
        st.table(dfp)
    st.markdown('</div>', unsafe_allow_html=True)

elif menu == "About":
    st.markdown('<div class="block-container fade-in">', unsafe_allow_html=True)
    st.header("About BloodChain 2.0 (Aidera)")
    st.markdown("""
    **What this demo does:**
    - Records donors and donation events in a local SQLite database (offline-first).
    - Tracks reward points for donors.
    - Aggregates donation data weekly to predict blood shortages using AI (if scikit-learn is available).

    **Notes & next steps you can ask me to do:**
    - Wire up on-chain contract ABI and onchain functions (if you want real blockchain logging).
    - Add CI/CD (Dockerfile, requirements.txt, GitHub Actions) and deploy to a server.
    - Add animations / Lottie or progress flows for nicer experience.
    - Export / import CSV backup & admin features.
    """)
    st.markdown('</div>', unsafe_allow_html=True)

# End of file
